#!/usr/bin/env ruby

require "optparse"
require "netrc"
require "octokit"
require "toml"
require "pp"
require "faraday-http-cache"

def github
  @github ||= begin
    faraday = Faraday::RackBuilder.new do |builder|
      builder.use Faraday::HttpCache
      builder.use Octokit::Response::RaiseError
      builder.adapter Faraday.default_adapter
    end

    connection = Octokit::Client.new(:netrc => true)
    connection.auto_paginate = true
    connection.middleware = faraday
    connection.per_page = 100
    connection
  end
end

# Some ground rules:
# We'll never rename a label
# To do mappings, we'll create the new label, and then for each issue
# with the old label, we'll add the new label, then remove the old one.
def ensure_label(repository, label)
  mappings = label.fetch("mappings") {[]}
  all = github.labels(repository)

  if label["delete"]
    puts "  Deleted label: '#{label['name']}'" if github.delete_label!(repository, label["name"])
    return
  end

  current = all.select { |cur| cur[:name] == label["name"]}.first
  if current.nil?
    github.add_label(repository, label["name"], label["color"])
    puts "  Successfully added label"
  else
    unless current[:color] == label["color"]
      github.update_label(repository, label["name"], color: label["color"])
      puts "  Updated color for #{label['name']}"
    end
  end

  mappings.each do |previous|
    next unless all.any? { |l| l[:name] == previous }
    puts "Working on #{previous} mapping for #{label['name']}"
    count = 0
    issues_with(repository, "label", previous) do |issue|
      puts "  Updating issue #{issue}"
      puts "  Adding label: '#{label['name']}'"
      github.add_labels_to_an_issue(repository, issue, [label["name"]])
      puts "  Removing label '#{previous}'"
      github.remove_label(repository, issue, previous)
      count += 1
      puts "-----"
    end
    # search is a bit slow, so we'll check that we deleted the number
    # that we expected or we've got none left. Of course, if search
    # updates while we're deleting a huge list we'll need to re-run, but
    # that should be OK
    remaining = issues_with(repository, "label", previous)
    if remaining.empty? || remaining.length == count
      puts "  Deleting label '#{previous}' from #{repository}"
      github.delete_label!(repository, previous)
    else
      puts "There are remaining issues returned from search - you should manually check that the '#{previous}' label has no tickets assigned (or rerun this command in a few minutes time)"
    end
  end
end

# Same basic rules as for labels, but we have to edit issues to set the
# milestone rather than updating the list of labels.
# TODO: handle state and due_date
def ensure_milestone(repository, milestone)
  mappings = milestone.delete("mappings") { [] }
  all = github.milestones(repository)

  current = all.select { |cur| cur[:title] == milestone["name"]}.first
  new = current

  if current.nil?
    new = github.create_milestone(repository, milestone["name"], description: milestone["description"])
    puts "  Successfully added milestone"
  else
    unless current[:title] == milestone["name"] && current[:description] == milestone["description"]
      github.update_milestone(repository, current[:number], title: milestone["name"], description: milestone["description"])
      puts "Updated milestone"
    end
  end

  mappings.each do |previous|
    next unless all.any? { |l| l[:title] == previous }
    previous_number = all.select { |l| l[:title] == previous }.first[:number]

    count = 0
    issues_with(repository, "milestone", previous) do |issue|
      puts "  Setting milestone on issue #{issue}"
      github.update_issue(repository, issue, milestone: new[:number])
      count += 1
      puts "-----"
    end
    # search is a bit slow, so we'll check that we deleted the number
    # that we expected or we've got none left. Of course, if search
    # updates while we're deleting a huge list we'll need to re-run, but
    # that should be OK
    remaining = issues_with(repository, "milestone", previous)
    if remaining.empty? || remaining.length == count
      puts "  Deleting milestone '#{previous}' from #{repository}"
      github.delete_milestone(repository, previous_number)
    else
      puts "There are remaining issues returned from search - you should manually check that the '#{previous}' milestone has no tickets assigned (or rerun this command in a few minutes time)"
    end
  end
end

# Yields each issue number that has the label or milestone
# Returns an array of all issues that have the label
def issues_with(repository, type, label, &block)
  query_string = "repo:#{repository} #{type}:\"#{label}\""
  issues = github.search_issues(query_string)[:items].map { |item| item[:number] }

  if block_given?
    issues.each do |issue|
      yield(issue)
    end
  end

  issues
end

Octokit.auto_paginate = true

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: repo_man [options]"

  opts.on("-c", "--config-file FILE", "The configuration to use") do |cfg|
    options["config"] = cfg
  end

  opts.on("-v", "--verbose", "Make repo man verbose") do
    options["verbose"] = true
  end

  opts.on("-h", "--help", "Prints this help") do
    puts opts
    exit
  end
end.parse!

config = TOML.load_file(options["config"])
config['repositories'].each do |repo|
  unless config['label'].nil?
    config['label'].each do |label|
      puts "Working on label '#{label['name']}' for '#{repo}'"
      ensure_label(repo, label)
    end
  end
  unless config['milestones'].nil?
    config['milestones'].each do |milestone|
      puts "Working on milestone '#{milestone['name']}' for '#{repo}'"
      ensure_milestone(repo, milestone)
    end
  end
end
